#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use super::p2_addresses::{alice_ecdsa, alice_sr25519};
use sp_core::ecdsa::{Pair as ECDSAPair, Signature as ECDSASignature};
use sp_core::ed25519::{Pair as Ed25519Pair, Signature as Ed25519Signature};
use sp_core::sr25519::{Pair as Sr25519Pair, Signature as Sr25519Signature};
use sp_core::Pair;
use sp_runtime::traits::{IdentifyAccount, Verify};
use sp_runtime::{MultiSignature, MultiSigner};

const BASE_MESSAGE: &[u8] = b"I'm signing this from PBA Berkeley 2023!";

/// Sign the base message as Alice using sr25519
pub fn sign_alice_sr25519() -> Sr25519Signature {
    alice_sr25519().sign(BASE_MESSAGE)
}

/// Verify a signature over the base message, signed by alice using sr25519
pub fn verify_alice_sig_sr25519(sig: Sr25519Signature) -> bool {
    sig.verify(BASE_MESSAGE, &alice_sr25519().public())
}

/// Sign the base message as Alice using sr25519, returning a MultiSignature.
///
/// A MultiSignature is just an enum over signatures generated by different cryptographies.
pub fn sign_alice_sr25519_ms() -> MultiSignature {
    MultiSignature::Sr25519(sign_alice_sr25519())
}

/// Verify a multisignature over the base message, signed by alice using sr25519.
pub fn verify_alice_sig_sr25519_ms(sig: MultiSignature) -> bool {
    match sig {
        MultiSignature::Sr25519(sig) => verify_alice_sig_sr25519(sig),
        _ => false,
    }
}

/// Sign the base message as Alice using ECDSA
pub fn sign_alice_ecdsa_ms() -> MultiSignature {
    MultiSignature::Ecdsa(alice_ecdsa().sign(BASE_MESSAGE))
}

/// Verify a multisignature over the base message, signed by alice using ecdsa.
///
/// If you get stuck figuring out to verify with an ecdsa public key, take a look at MultiSigner
pub fn verify_alice_sig_ecdsa_ms(sig: MultiSignature) -> bool {
    match sig {
        MultiSignature::Ecdsa(sig) => sig.verify(BASE_MESSAGE, &alice_ecdsa().public()),
        _ => false,
    }
}

/// Recover a public key from a multisignature if it's an ECDSA signature, otherwise return None
pub fn try_recover_ecdsa_pubkey(sig: MultiSignature, msg: &[u8]) -> Option<sp_core::ecdsa::Public> {
    match sig {
        MultiSignature::Ecdsa(sig) => Some(sig.recover(msg)?),
        _ => None,
    }
}

/// Return true iff sig1 and sig2 are both signatures over msg from signer.
pub fn signatures_equivalent(
    sig1: MultiSignature,
    sig2: MultiSignature,
    signer: MultiSigner,
    msg: &[u8],
) -> bool {
    // FIXME
    // You can't always just compare signatures directly. Can you figure out why?
    let account = signer.into_account();
    sig1.verify(msg, &account) && sig2.verify(msg, &account)
}

/// This function is not graded. It is just for collecting feedback.
/// On a scale from 0 - 100, with zero being extremely easy and 100 being extremely hard, how hard
/// did you find the exercises in this section?
pub fn how_hard_was_this_section() -> u8 {
    40
}

/// This function is not graded. It is just for collecting feedback.
/// About how much time (in hours) did you spend on the exercises in this section?
pub fn how_many_hours_did_you_spend_on_this_section() -> f32 {
    1.5
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sign_alice_sr25519_test() {
        // This test relies on `alice_sr25519`'s correctness to pass.
        let sig = sign_alice_sr25519();
        assert!(verify_alice_sig_sr25519(sig));

        let bad_sig_data = [5u8; 64];
        let bad_sig = Sr25519Signature::try_from(bad_sig_data.as_slice()).unwrap();
        assert!(!verify_alice_sig_sr25519(bad_sig));

        let other_sig = Sr25519Pair::from_string("//Bob", None)
            .unwrap()
            .sign(BASE_MESSAGE);
        assert!(!verify_alice_sig_sr25519(other_sig));
    }

    #[test]
    fn sign_alice_sr25519_ms_test() {
        // This test relies on `alice_sr25519`'s correctness to pass.
        let sig = sign_alice_sr25519_ms();
        assert!(verify_alice_sig_sr25519_ms(sig));

        let bad_sig_data = [5u8; 64];
        let bad_sig = Sr25519Signature::try_from(bad_sig_data.as_slice()).unwrap();
        assert!(!verify_alice_sig_sr25519_ms(bad_sig.into()));

        let other_sig = Sr25519Pair::from_string("//Bob", None)
            .unwrap()
            .sign(BASE_MESSAGE);
        assert!(!verify_alice_sig_sr25519_ms(other_sig.into()));
    }

    #[test]
    fn sign_alice_ecdsa_ms_test() {
        // This test relies on `alice_sr25519`'s correctness to pass.
        let sig = sign_alice_ecdsa_ms();
        assert!(verify_alice_sig_ecdsa_ms(sig));

        let bad_sig_data = [5u8; 64];
        let bad_sig = Sr25519Signature::try_from(bad_sig_data.as_slice()).unwrap();
        assert!(!verify_alice_sig_ecdsa_ms(bad_sig.into()));

        let other_sig = ECDSAPair::from_string("//Bob", None)
            .unwrap()
            .sign(BASE_MESSAGE);
        assert!(!verify_alice_sig_ecdsa_ms(other_sig.into()));
    }

    #[test]
    fn try_recover_ecdsa_pubkey_test() {
        let bob = ECDSAPair::from_string("//Bob", None).unwrap();
        let sig = bob.sign(BASE_MESSAGE);

        assert_eq!(
            Some(bob.public()),
            try_recover_ecdsa_pubkey(sig.clone().into(), BASE_MESSAGE)
        );

        // Notice that it recovers a wrong public key with the wrong message
        assert!(matches!(
            try_recover_ecdsa_pubkey(sig.clone().into(), b"wrong message here"),
            Some(x) if x != bob.public(),
        ));

        let bad_sig_data = [5u8; 64];
        let bad_sig = Sr25519Signature::try_from(bad_sig_data.as_slice()).unwrap();
        assert_eq!(None, try_recover_ecdsa_pubkey(bad_sig.into(), BASE_MESSAGE));
    }

    #[test]
    fn signatures_equivalent_test() {
        let msg = b"PBA Berkeley!";
        let keypair = alice_sr25519();
        let sig1 = keypair.sign(msg);
        let sig2 = keypair.sign(msg);

        assert!(signatures_equivalent(
            sig1.into(),
            sig2.into(),
            keypair.public().into(),
            msg
        ));
    }

    #[test]
    fn signatures_equivalent_ed25519_test() {
        let msg = b"PBA Berkeley!";
        let keypair = Ed25519Pair::from_string("//Alice", None).unwrap();
        let sig1 = keypair.sign(msg);
        let sig2 = keypair.sign(msg);

        assert!(signatures_equivalent(
            sig1.into(),
            sig2.into(),
            keypair.public().into(),
            msg
        ));
    }
}
